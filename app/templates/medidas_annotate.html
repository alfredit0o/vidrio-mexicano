{% extends "base.html" %}
{% block content %}
<h2>Anotar medidas: {{ nombre }}</h2>
<p>1) (Opcional) Calibra: dibuja una l√≠nea de referencia y escribe su largo en mm ‚Üí el sistema calcular√° mm/p√≠xel.<br>
2) Dibuja flechas: clic y arrastra. Se mostrar√° la medida estimada; puedes editar el texto.</p>

<div style="display:flex; gap:16px; align-items:flex-start;">
  <div>
    <canvas id="board" width="960" height="720" style="border:1px solid #ccc; touch-action:none"></canvas>
    <div style="margin-top:8px;">
      <button id="undoBtn">‚Ü©Ô∏è Deshacer</button>
      <button id="clearBtn">üóëÔ∏è Limpiar</button>
      <button id="saveBtn">üíæ Guardar anotaciones</button>
    </div>
  </div>
  <div style="min-width:260px;">
    <fieldset>
      <legend>Calibraci√≥n</legend>
      <label>mm/pixel:
        <input id="mmpp" type="number" step="0.0001" placeholder="Ej. 0.25">
      </label>
      <p style="font-size:12px;color:#555">
        O dibuja una l√≠nea de referencia y escribe su largo:
      </p>
      <label>Longitud referencia (mm):
        <input id="refmm" type="number" step="0.01">
      </label>
      <button id="useRef">Usar referencia</button>
    </fieldset>
    <fieldset style="margin-top:12px;">
      <legend>Flecha seleccionada</legend>
      <label>Etiqueta (mm):
        <input id="labelInput" type="text" placeholder="ej: 123.4 mm">
      </label>
      <button id="applyLabel">Aplicar</button>
    </fieldset>
  </div>
</div>

<form id="saveForm" method="post" action="{{ url_for('medidas.annotate', fid=foto_id) }}">
  <input type="hidden" name="dataurl" id="dataurl">
  <input type="hidden" name="anotaciones" id="anotaciones">
</form>

<script>
const baseImageURL = "{{ base_image|safe }}";
const initialAnnotations = {{ anotaciones|tojson }};

const board = document.getElementById('board');
const ctx = board.getContext('2d');

const mmppInput = document.getElementById('mmpp');
const refmmInput = document.getElementById('refmm');
const useRefBtn = document.getElementById('useRef');

const labelInput = document.getElementById('labelInput');
const applyLabelBtn = document.getElementById('applyLabel');

const undoBtn = document.getElementById('undoBtn');
const clearBtn = document.getElementById('clearBtn');
const saveBtn = document.getElementById('saveBtn');

const dataurlEl = document.getElementById('dataurl');
const anotEl = document.getElementById('anotaciones');

let baseImg = new Image();
baseImg.onload = () => { fitAndRender(); };
baseImg.src = baseImageURL;

let scaleFit = 1, offsetX = 0, offsetY = 0;

// flechas: {x1,y1,x2,y2,label}
let arrows = Array.isArray(initialAnnotations) ? initialAnnotations : [];
let current = null;
let selectedIndex = -1;
let isDragging = false;
let mmpp = 0; // mm por p√≠xel

function fitAndRender() {
  // Ajustamos la foto a canvas manteniendo aspecto
  const w = board.width, h = board.height;
  ctx.fillStyle = "#eee"; ctx.fillRect(0,0,w,h);
  const iw = baseImg.width, ih = baseImg.height;
  const s = Math.min(w/iw, h/ih);
  scaleFit = s;
  offsetX = (w - iw*s)/2; offsetY = (h - ih*s)/2;
  draw();
}

function drawArrow(a, color, lineW=2) {
  const x1 = offsetX + a.x1*scaleFit, y1 = offsetY + a.y1*scaleFit;
  const x2 = offsetX + a.x2*scaleFit, y2 = offsetY + a.y2*scaleFit;
  // l√≠nea
  ctx.lineWidth = lineW; ctx.strokeStyle = color;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  // cabeza de flecha
  const ang = Math.atan2(y2-y1, x2-x1);
  const len = 12;
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2 - len*Math.cos(ang - Math.PI/6), y2 - len*Math.sin(ang - Math.PI/6));
  ctx.lineTo(x2 - len*Math.cos(ang + Math.PI/6), y2 - len*Math.sin(ang + Math.PI/6));
  ctx.closePath();
  ctx.fillStyle = color; ctx.fill();
  // etiqueta
  if (a.label) {
    ctx.font = "16px sans-serif"; ctx.fillStyle = color;
    const mx = (x1+x2)/2, my = (y1+y2)/2;
    ctx.fillText(a.label, mx+6, my-6);
  }
}

function draw() {
  ctx.fillStyle = "#eee"; ctx.fillRect(0,0,board.width,board.height);
  if (baseImg) ctx.drawImage(baseImg, offsetX, offsetY, baseImg.width*scaleFit, baseImg.height*scaleFit);
  // todas las flechas
  arrows.forEach((a,i)=> drawArrow(a, i===selectedIndex ? "#d33" : "#0a58ca", i===selectedIndex ? 3 : 2));
  // actual (en curso)
  if (current) drawArrow(current, "#198754", 2);
}

function canvasToImageCoords(px, py) {
  // inversa del fit
  const x = (px - offsetX)/scaleFit;
  const y = (py - offsetY)/scaleFit;
  return {x,y};
}

board.addEventListener('pointerdown', (e)=>{
  const rect = board.getBoundingClientRect();
  const p = canvasToImageCoords(e.clientX - rect.left, e.clientY - rect.top);
  current = {x1:p.x, y1:p.y, x2:p.x, y2:p.y, label:""};
  isDragging = true;
  selectedIndex = -1;
  draw();
});
board.addEventListener('pointermove', (e)=>{
  if (!isDragging || !current) return;
  const rect = board.getBoundingClientRect();
  const p = canvasToImageCoords(e.clientX - rect.left, e.clientY - rect.top);
  current.x2 = p.x; current.y2 = p.y;
  draw();
});
board.addEventListener('pointerup', (e)=>{
  if (!current) return;
  isDragging = false;
  // calcular largo en p√≠xeles
  const dx = current.x2 - current.x1, dy = current.y2 - current.y1;
  const pxLen = Math.sqrt(dx*dx + dy*dy);
  let label = "";
  if (mmpp > 0) {
    const mm = pxLen * mmpp;
    label = mm.toFixed(1) + " mm";
  }
  current.label = label;
  arrows.push(current);
  selectedIndex = arrows.length - 1;
  labelInput.value = label || "";
  current = null;
  draw();
});

undoBtn.onclick = ()=> {
  if (current) { current=null; draw(); return; }
  if (arrows.length>0) {
    arrows.pop(); selectedIndex=-1; draw();
  }
};
clearBtn.onclick = ()=> { arrows = []; selectedIndex=-1; draw(); };

board.addEventListener('click', (e)=>{
  // seleccionar flecha cercana al click para editar etiqueta
  const rect = board.getBoundingClientRect();
  const p = canvasToImageCoords(e.clientX - rect.left, e.clientY - rect.top);
  let best=-1, bestd=9999;
  arrows.forEach((a,i)=>{
    // distancia al punto medio
    const mx=(a.x1+a.x2)/2, my=(a.y1+a.y2)/2;
    const d = Math.hypot(mx-p.x, my-p.y);
    if (d<bestd && d<30/scaleFit) { best=i; bestd=d; }
  });
  selectedIndex = best;
  if (best>=0) labelInput.value = arrows[best].label || "";
  draw();
});

applyLabelBtn.onclick = ()=> {
  if (selectedIndex<0) return;
  arrows[selectedIndex].label = labelInput.value || "";
  draw();
};

// calibraci√≥n por referencia
useRefBtn.onclick = ()=> {
  if (!arrows.length) { alert("Dibuja primero una l√≠nea de referencia."); return; }
  const a = arrows[arrows.length-1];
  const dx = a.x2-a.x1, dy=a.y2-a.y1;
  const pxLen = Math.sqrt(dx*dx + dy*dy);
  const mm = parseFloat(refmmInput.value || "0");
  if (pxLen>0 && mm>0) {
    mmpp = mm / pxLen;
    mmppInput.value = mmpp.toFixed(6);
    // actualiza etiqueta de la referencia
    a.label = mm.toFixed(1) + " mm";
    draw();
  } else {
    alert("Ingresa una longitud v√°lida (mm) y dibuja la referencia.");
  }
};
mmppInput.addEventListener('change', ()=>{
  mmpp = parseFloat(mmppInput.value || "0") || 0;
});

saveBtn.onclick = ()=> {
  // render final (base + flechas) a PNG en el mismo canvas
  draw();
  const png = board.toDataURL("image/png");
  dataurlEl.value = png;
  anotEl.value = JSON.stringify(arrows);
  document.getElementById('saveForm').submit();
};
</script>
{% endblock %}
